{"version":3,"sources":["../src/index.ts","../node_modules/change-case/src/index.ts","../src/utils.ts"],"sourcesContent":["import type { Dictionary } from 'style-dictionary/types/DesignToken'\nimport type { Config } from 'style-dictionary/types/Config'\nimport type { SdTailwindConfigType, TailwindFormatObjType } from './types'\nimport {\n  addHyphen,\n  getConfigValue,\n  makeSdObject,\n  unquoteFromKeys,\n  getTemplateConfigByType\n} from './utils'\n\nconst formatTokens = (\n  tokens: Dictionary['allTokens'],\n  type: SdTailwindConfigType['type'],\n  isVariables: SdTailwindConfigType['isVariables'],\n  prefix: SdTailwindConfigType['prefix']\n) => {\n  const allTokenObj = tokens.reduce<Record<string, string>>((acc, cur) => {\n    if (cur.attributes === undefined) {\n      throw new Error(`Token ${cur.name} has no attributes`)\n    }\n\n    if (cur.attributes.category === type || type === 'all') {\n      /**\n       * Make sure screens values are not using CSS variables as\n       * CSS @media queries do not support CSS variables\n       */\n      if (isVariables && cur.attributes.category !== 'screens') {\n        acc[Object.values(cur.attributes).join('.')] = prefix\n          ? `var(--${addHyphen(prefix) + cur.name})`\n          : `var(--${cur.name})`\n      } else {\n        acc[Object.values(cur.attributes).join('.')] = cur[\"$value\"] || cur[\"value\"]\n      }\n    }\n\n    return acc\n  }, {})\n\n  const result = {}\n  Object.keys(allTokenObj).forEach((key) => {\n    const keys = key.split('.').filter((k) => k !== type)\n    makeSdObject(result, keys, allTokenObj[key])\n  })\n\n  return JSON.stringify(result, null, 2)\n}\n\nexport const getTailwindFormat = ({\n  dictionary: { allTokens },\n  type,\n  isVariables,\n  prefix,\n  extend,\n  tailwind\n}: TailwindFormatObjType) => {\n  const content = formatTokens(allTokens, type, isVariables, prefix)\n\n  if (type === 'all') {\n    const darkMode = getConfigValue(tailwind?.darkMode, 'class')\n\n    const tailwindContent = getConfigValue(\n      Array.isArray(tailwind?.content)\n        ? tailwind?.content.map((content) => `\"${content}\"`)\n        : tailwind?.content,\n      [`\"./src/**/*.{ts,tsx}\"`]\n    )\n\n    const plugins = getConfigValue(\n      tailwind?.plugins?.map((plugin) => {\n        return `require(\"@tailwindcss/${plugin}\")`\n      }),\n      []\n    )\n\n    const configs = getTemplateConfigByType(\n      type,\n      content,\n      darkMode,\n      tailwindContent,\n      extend,\n      plugins\n    )\n\n    return configs\n  } else {\n    return `module.exports = ${unquoteFromKeys(content)}`\n  }\n}\n\nexport const makeSdTailwindConfig = ({\n  type,\n  formatType = 'js',\n  isVariables = false,\n  extend = true,\n  source,\n  transforms,\n  buildPath,\n  prefix,\n  tailwind,\n  preprocessors\n}: SdTailwindConfigType): Config => {\n  if (type === undefined) {\n    throw new Error('type is required')\n  }\n\n  if (formatType !== 'js' && formatType !== 'cjs') {\n    throw new Error('formatType must be \"js\" or \"cjs\"')\n  }\n\n  return {\n    preprocessors,\n    source: getConfigValue(source, ['tokens/**/*.json']),\n    hooks: {\n      formats: {\n        tailwindFormat: ({ dictionary }: { dictionary: Dictionary }) => {\n          return getTailwindFormat({\n            dictionary,\n            formatType,\n            isVariables,\n            extend,\n            prefix,\n            type,\n            tailwind\n          })\n        }\n      }\n    },\n    platforms: {\n      [type !== 'all' ? `tailwind/${type}` : 'tailwind']: {\n        transforms: getConfigValue(transforms, [\n          'attribute/cti',\n          'name/kebab'\n        ]),\n        buildPath: getConfigValue(buildPath, 'build/web/'),\n        files: [\n          {\n            destination:\n              type !== 'all'\n                ? `${type}.tailwind.js`\n                : `tailwind.config.${formatType}`,\n            format: 'tailwindFormat'\n          }\n        ]\n      }\n    }\n  }\n}\n","// Regexps involved with splitting words in various case formats.\nconst SPLIT_LOWER_UPPER_RE = /([\\p{Ll}\\d])(\\p{Lu})/gu;\nconst SPLIT_UPPER_UPPER_RE = /(\\p{Lu})([\\p{Lu}][\\p{Ll}])/gu;\n\n// Used to iterate over the initial split result and separate numbers.\nconst SPLIT_SEPARATE_NUMBER_RE = /(\\d)\\p{Ll}|(\\p{L})\\d/u;\n\n// Regexp involved with stripping non-word characters from the result.\nconst DEFAULT_STRIP_REGEXP = /[^\\p{L}\\d]+/giu;\n\n// The replacement value for splits.\nconst SPLIT_REPLACE_VALUE = \"$1\\0$2\";\n\n// The default characters to keep after transforming case.\nconst DEFAULT_PREFIX_SUFFIX_CHARACTERS = \"\";\n\n/**\n * Supported locale values. Use `false` to ignore locale.\n * Defaults to `undefined`, which uses the host environment.\n */\nexport type Locale = string[] | string | false | undefined;\n\n/**\n * Options used for converting strings to pascal/camel case.\n */\nexport interface PascalCaseOptions extends Options {\n  mergeAmbiguousCharacters?: boolean;\n}\n\n/**\n * Options used for converting strings to any case.\n */\nexport interface Options {\n  locale?: Locale;\n  split?: (value: string) => string[];\n  /** @deprecated Pass `split: splitSeparateNumbers` instead. */\n  separateNumbers?: boolean;\n  delimiter?: string;\n  prefixCharacters?: string;\n  suffixCharacters?: string;\n}\n\n/**\n * Split any cased input strings into an array of words.\n */\nexport function split(value: string) {\n  let result = value.trim();\n\n  result = result\n    .replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE)\n    .replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE);\n\n  result = result.replace(DEFAULT_STRIP_REGEXP, \"\\0\");\n\n  let start = 0;\n  let end = result.length;\n\n  // Trim the delimiter from around the output string.\n  while (result.charAt(start) === \"\\0\") start++;\n  if (start === end) return [];\n  while (result.charAt(end - 1) === \"\\0\") end--;\n\n  return result.slice(start, end).split(/\\0/g);\n}\n\n/**\n * Split the input string into an array of words, separating numbers.\n */\nexport function splitSeparateNumbers(value: string) {\n  const words = split(value);\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const match = SPLIT_SEPARATE_NUMBER_RE.exec(word);\n    if (match) {\n      const offset = match.index + (match[1] ?? match[2]).length;\n      words.splice(i, 1, word.slice(0, offset), word.slice(offset));\n    }\n  }\n  return words;\n}\n\n/**\n * Convert a string to space separated lower case (`foo bar`).\n */\nexport function noCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  return (\n    prefix +\n    words.map(lowerFactory(options?.locale)).join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to camel case (`fooBar`).\n */\nexport function camelCase(input: string, options?: PascalCaseOptions) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = options?.mergeAmbiguousCharacters\n    ? capitalCaseTransformFactory(lower, upper)\n    : pascalCaseTransformFactory(lower, upper);\n  return (\n    prefix +\n    words\n      .map((word, index) => {\n        if (index === 0) return lower(word);\n        return transform(word, index);\n      })\n      .join(options?.delimiter ?? \"\") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to pascal case (`FooBar`).\n */\nexport function pascalCase(input: string, options?: PascalCaseOptions) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = options?.mergeAmbiguousCharacters\n    ? capitalCaseTransformFactory(lower, upper)\n    : pascalCaseTransformFactory(lower, upper);\n  return prefix + words.map(transform).join(options?.delimiter ?? \"\") + suffix;\n}\n\n/**\n * Convert a string to pascal snake case (`Foo_Bar`).\n */\nexport function pascalSnakeCase(input: string, options?: Options) {\n  return capitalCase(input, { delimiter: \"_\", ...options });\n}\n\n/**\n * Convert a string to capital case (`Foo Bar`).\n */\nexport function capitalCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  return (\n    prefix +\n    words\n      .map(capitalCaseTransformFactory(lower, upper))\n      .join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to constant case (`FOO_BAR`).\n */\nexport function constantCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  return (\n    prefix +\n    words.map(upperFactory(options?.locale)).join(options?.delimiter ?? \"_\") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to dot case (`foo.bar`).\n */\nexport function dotCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \".\", ...options });\n}\n\n/**\n * Convert a string to kebab case (`foo-bar`).\n */\nexport function kebabCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"-\", ...options });\n}\n\n/**\n * Convert a string to path case (`foo/bar`).\n */\nexport function pathCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"/\", ...options });\n}\n\n/**\n * Convert a string to path case (`Foo bar`).\n */\nexport function sentenceCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = capitalCaseTransformFactory(lower, upper);\n  return (\n    prefix +\n    words\n      .map((word, index) => {\n        if (index === 0) return transform(word);\n        return lower(word);\n      })\n      .join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to snake case (`foo_bar`).\n */\nexport function snakeCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"_\", ...options });\n}\n\n/**\n * Convert a string to header case (`Foo-Bar`).\n */\nexport function trainCase(input: string, options?: Options) {\n  return capitalCase(input, { delimiter: \"-\", ...options });\n}\n\nfunction lowerFactory(locale: Locale): (input: string) => string {\n  return locale === false\n    ? (input: string) => input.toLowerCase()\n    : (input: string) => input.toLocaleLowerCase(locale);\n}\n\nfunction upperFactory(locale: Locale): (input: string) => string {\n  return locale === false\n    ? (input: string) => input.toUpperCase()\n    : (input: string) => input.toLocaleUpperCase(locale);\n}\n\nfunction capitalCaseTransformFactory(\n  lower: (input: string) => string,\n  upper: (input: string) => string,\n) {\n  return (word: string) => `${upper(word[0])}${lower(word.slice(1))}`;\n}\n\nfunction pascalCaseTransformFactory(\n  lower: (input: string) => string,\n  upper: (input: string) => string,\n) {\n  return (word: string, index: number) => {\n    const char0 = word[0];\n    const initial =\n      index > 0 && char0 >= \"0\" && char0 <= \"9\" ? \"_\" + char0 : upper(char0);\n    return initial + lower(word.slice(1));\n  };\n}\n\nfunction splitPrefixSuffix(\n  input: string,\n  options: Options = {},\n): [string, string[], string] {\n  const splitFn =\n    options.split ?? (options.separateNumbers ? splitSeparateNumbers : split);\n  const prefixCharacters =\n    options.prefixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;\n  const suffixCharacters =\n    options.suffixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;\n  let prefixIndex = 0;\n  let suffixIndex = input.length;\n\n  while (prefixIndex < input.length) {\n    const char = input.charAt(prefixIndex);\n    if (!prefixCharacters.includes(char)) break;\n    prefixIndex++;\n  }\n\n  while (suffixIndex > prefixIndex) {\n    const index = suffixIndex - 1;\n    const char = input.charAt(index);\n    if (!suffixCharacters.includes(char)) break;\n    suffixIndex = index;\n  }\n\n  return [\n    input.slice(0, prefixIndex),\n    splitFn(input.slice(prefixIndex, suffixIndex)),\n    input.slice(suffixIndex),\n  ];\n}\n","import { camelCase } from 'change-case'\nimport type { SdObjType, SdTailwindConfigType, TailwindOptions } from './types'\n\nexport const addHyphen = (str: string) => {\n  return str.endsWith('-') ? str : `${str}-`\n}\n\nexport const makeSdObject = <T extends readonly string[]>(\n  obj: SdObjType<{ [key: string]: any }>,\n  keys: T,\n  value: string\n): void => {\n  const lastIndex = keys.length - 1\n  for (let i = 0; i < lastIndex; ++i) {\n    const key = camelCase(keys[i])\n    if (!(key in obj)) {\n      obj[key] = {}\n    }\n    obj = obj[key]\n  }\n\n  // https://v2.tailwindcss.com/docs/upgrading-to-v2#update-default-theme-keys-to-default\n  if (keys[lastIndex] === 'DEFAULT') {\n    obj[keys[lastIndex]] = value\n  } else {\n    obj[camelCase(keys[lastIndex])] = value\n  }\n}\n\nexport const getConfigValue = <T>(value: T | undefined, defaultValue: T) => {\n  if (value === undefined) {\n    return defaultValue\n  }\n\n  return value\n}\n\nconst joinSpace = (value: string, spaceNum: number, type?: string) => {\n  const space = ' '.repeat(spaceNum)\n\n  if (type !== 'all') {\n    return value\n  }\n\n  return space + value\n}\n\nexport const unquoteFromKeys = (json: string, type?: string, spaceNum = 4) => {\n  const result = json.replace(/\"(\\\\[^]|[^\\\\\"])*\"\\s*:?/g, (match) => {\n    if (/[0-9]/.test(match) && /[a-zA-Z]/.test(match)) {\n      return match\n    }\n    if (/:$/.test(match)) {\n      return joinSpace(match.replace(/^\"|\"(?=\\s*:$)/g, ''), spaceNum, type)\n    }\n\n    return match\n  })\n\n  return result.replace(/}/g, (match) => joinSpace(match, spaceNum, type))\n}\n\nexport const getTemplateConfigByType = (\n  type: SdTailwindConfigType['type'],\n  content: string,\n  darkMode: TailwindOptions['darkMode'],\n  tailwindContent: TailwindOptions['content'],\n  extend: SdTailwindConfigType['extend'],\n  plugins: string[]\n) => {\n  const extendTheme = extend\n    ? `theme: {\n    extend: ${unquoteFromKeys(content, type, 4)},\n  },`\n    : `theme: ${unquoteFromKeys(content, type, 2)},`\n\n  const getTemplateConfig = () => {\n    let config = `{\n  mode: \"jit\",\n  content: [${tailwindContent}],\n  darkMode: \"${darkMode}\",\n  ${extendTheme}`\n\n    if (plugins.length > 0) {\n      config += `\\n  plugins: [${plugins}]`\n    }\n\n    config += '\\n}'\n\n    return config\n  }\n\n  const configs = `/** @type {import('tailwindcss').Config} */\\nmodule.exports = ${getTemplateConfig()}`\n\n  return configs\n}\n"],"mappings":"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","names":["content"]}